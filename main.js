/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OpenInterpreterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var os = __toESM(require("os"));
var fs = __toESM(require("fs/promises"));
var DEFAULT_SETTINGS = {
  apiKey: ""
};
var InstallationGuideModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.setText("Open Interpreter is not installed.");
    contentEl.createEl("p", {
      text: "To install, run the following command in your terminal:"
    });
    contentEl.createEl("pre", { text: "pip install open-interpreter" });
    contentEl.createEl("p", { text: "For more information, visit:" });
    contentEl.createEl("a", {
      text: "Open Interpreter Documentation",
      href: "https://docs.openinterpreter.com/getting-started/introduction"
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var InterpreterInputModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.result = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Enter command for Open Interpreter" });
    new import_obsidian.Setting(contentEl).setName("Command").addText(
      (text) => text.onChange((value) => {
        this.result = value;
      })
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result);
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var InterpreterChatModal = class extends import_obsidian.Modal {
  constructor(app, interpreter) {
    super(app);
    this.interpreter = interpreter;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Open Interpreter Chat" });
    this.outputEl = contentEl.createEl("div", { cls: "interpreter-output" });
    this.outputEl.style.height = "400px";
    this.outputEl.style.overflowY = "scroll";
    this.outputEl.style.border = "1px solid #ccc";
    this.outputEl.style.padding = "10px";
    this.outputEl.style.marginBottom = "10px";
    this.createInputArea();
    this.createYesNoButtons();
    const sendButton = contentEl.createEl("button", { text: "Send" });
    sendButton.onclick = () => this.sendMessage();
    this.setupInterpreterListeners();
  }
  setupInterpreterListeners() {
    if (this.interpreter.stdout) {
      this.interpreter.stdout.on("data", (data) => {
        this.appendOutput(data.toString());
      });
    }
    if (this.interpreter.stderr) {
      this.interpreter.stderr.on("data", (data) => {
        this.appendOutput(`Error: ${data.toString()}`, true);
      });
    }
    this.interpreter.on("close", (code) => {
      this.appendOutput(`Interpreter closed with code ${code}`);
      this.close();
    });
  }
  onClose() {
    this.interpreter.kill();
    const { contentEl } = this;
    contentEl.empty();
  }
  appendOutput(text, isError = false) {
    const chunks = text.match(/.{1,1000}/g) || [];
    chunks.forEach((chunk) => {
      const p = this.outputEl.createEl("p");
      p.textContent = chunk;
      if (isError) {
        p.style.color = "red";
      }
    });
    this.outputEl.scrollTop = this.outputEl.scrollHeight;
    if (text.trim().endsWith("Would you like to run this code? (y/n)")) {
      this.showYesNoButtons();
    } else {
      this.showInputArea();
    }
  }
  sendMessage(overrideMessage) {
    let message;
    if (overrideMessage) {
      message = overrideMessage;
    } else {
      message = this.inputEl.value;
      this.inputEl.value = "";
    }
    if (this.interpreter.stdin) {
      this.interpreter.stdin.write(message + "\n");
    }
    this.appendOutput(`You: ${message}`);
    this.showInputArea();
  }
  createInputArea() {
    this.inputEl = this.contentEl.createEl("textarea", {
      cls: "interpreter-input"
    });
    this.inputEl.style.width = "100%";
    this.inputEl.style.height = "100px";
    this.inputEl.style.display = "block";
  }
  createYesNoButtons() {
    this.buttonContainer = this.contentEl.createEl("div", {
      cls: "yes-no-buttons"
    });
    this.buttonContainer.style.display = "flex";
    this.buttonContainer.style.justifyContent = "space-between";
    this.buttonContainer.style.marginTop = "10px";
    this.yesButton = this.buttonContainer.createEl("button", { text: "Yes" });
    this.yesButton.style.backgroundColor = "#e6ffe6";
    this.yesButton.style.color = "#006600";
    this.yesButton.style.border = "1px solid #006600";
    this.yesButton.style.padding = "10px 20px";
    this.yesButton.style.borderRadius = "5px";
    this.yesButton.style.cursor = "pointer";
    this.noButton = this.buttonContainer.createEl("button", { text: "No" });
    this.noButton.style.backgroundColor = "#ffe6e6";
    this.noButton.style.color = "#660000";
    this.noButton.style.border = "1px solid #660000";
    this.noButton.style.padding = "10px 20px";
    this.noButton.style.borderRadius = "5px";
    this.noButton.style.cursor = "pointer";
    this.yesButton.onclick = () => this.sendMessage("y");
    this.noButton.onclick = () => this.sendMessage("n");
    this.buttonContainer.style.display = "none";
  }
  showInputArea() {
    this.inputEl.style.display = "block";
    this.buttonContainer.style.display = "none";
  }
  showYesNoButtons() {
    this.inputEl.style.display = "none";
    this.buttonContainer.style.display = "block";
  }
};
var OpenInterpreterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.interpreterInstalled = false;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new OpenInterpreterSettingTab(this.app, this));
    this.addCommand({
      id: "run-interpreter",
      name: "Run Open Interpreter",
      callback: () => this.runInterpreter()
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async checkInterpreterInstallation() {
    return new Promise((resolve) => {
      const command = '$SHELL -i -c "which interpreter"';
      console.log("Executing command:", command);
      (0, import_child_process.exec)(command, (error, stdout, stderr) => {
        if (error) {
          console.error("Error finding interpreter:", error);
          console.log("Stderr:", stderr);
          this.interpreterInstalled = false;
        } else {
          const interpreterPath = stdout.trim();
          console.log("Interpreter found at:", interpreterPath);
          this.interpreterInstalled = !!interpreterPath;
        }
        console.log("Interpreter installed:", this.interpreterInstalled);
        resolve();
      });
    });
  }
  async getInterpreterProfilePath() {
    const homedir2 = os.homedir();
    const profileDir = path.join(
      homedir2,
      "Library",
      "Application Support",
      "open-interpreter",
      "profiles"
    );
    const profilePath = path.join(profileDir, "obsidian.py");
    await fs.mkdir(profileDir, { recursive: true });
    if (!await fs.stat(profilePath).catch(() => false)) {
      await fs.writeFile(
        profilePath,
        "# Obsidian profile for Open Interpreter\n"
      );
    }
    return profilePath;
  }
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    if (adapter && "basePath" in adapter) {
      return adapter.basePath;
    }
    const rootFolder = this.app.vault.getRoot();
    if (rootFolder instanceof import_obsidian.TFolder) {
      return rootFolder.path;
    }
    console.error("Could not determine vault path");
    return null;
  }
  async runInterpreter() {
    await this.checkInterpreterInstallation();
    if (!this.interpreterInstalled) {
      console.log("Interpreter not installed, showing modal");
      new InstallationGuideModal(this.app).open();
      return;
    }
    new InterpreterInputModal(this.app, (command) => {
      this.executeInterpreterCommand(command);
    }).open();
  }
  async executeInterpreterCommand(command) {
    const profilePath = await this.getInterpreterProfilePath();
    const vaultPath = this.getVaultPath();
    if (!vaultPath) {
      console.error("Vault path could not be determined.");
      new import_obsidian.Notice(
        "Unable to determine vault path. Please check console for details."
      );
      return;
    }
    const interpreterPath = await this.getInterpreterPath();
    if (!interpreterPath) {
      new import_obsidian.Notice(
        "Unable to find the interpreter executable. Please make sure it's installed and in your PATH."
      );
      return;
    }
    const env = { ...process.env, OPENAI_API_KEY: this.settings.apiKey };
    const escapedProfilePath = profilePath.replace(/'/g, "'\\''");
    const child = (0, import_child_process.spawn)(
      interpreterPath,
      ["--profile", `'${escapedProfilePath}'`],
      {
        cwd: vaultPath,
        env,
        shell: true
      }
    );
    if (child.stdin) {
      child.stdin.write(command + "\n");
    }
    new InterpreterChatModal(this.app, child).open();
  }
  getInterpreterPath() {
    return new Promise((resolve) => {
      const isWindows = process.platform === "win32";
      const command = isWindows ? "where interpreter" : "$SHELL -i -c 'which interpreter'";
      console.log("Executing command:", command);
      (0, import_child_process.exec)(command, async (error, stdout, stderr) => {
        if (error) {
          console.error("Error finding interpreter:", error);
          console.log("Stdout:", stdout);
          console.log("Stderr:", stderr);
          const commonPaths = [
            "/usr/local/bin/interpreter",
            "/usr/bin/interpreter",
            `${os.homedir()}/Library/Python/3.11/bin/interpreter`,
            `${os.homedir()}/Library/Python/3.10/bin/interpreter`,
            `${os.homedir()}/Library/Python/3.9/bin/interpreter`
          ];
          for (const path2 of commonPaths) {
            try {
              await fs.access(path2);
              resolve(path2);
              return;
            } catch (e) {
            }
          }
          resolve(null);
        } else {
          console.log("Interpreter found at:", stdout.trim());
          resolve(stdout.trim());
        }
      });
    });
  }
  onunload() {
    console.log("unloading open interpreter plugin");
  }
};
var OpenInterpreterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Open Interpreter Settings" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key").addText(
      (text) => text.setPlaceholder("Enter your api key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7XG4gIFBsdWdpbixcbiAgTm90aWNlLFxuICBNb2RhbCxcbiAgQXBwLFxuICBURm9sZGVyLFxuICBTZXR0aW5nLFxuICBQbHVnaW5TZXR0aW5nVGFiLFxufSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGV4ZWMsIENoaWxkUHJvY2Vzcywgc3Bhd24gfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcblxuaW50ZXJmYWNlIE9wZW5JbnRlcnByZXRlclNldHRpbmdzIHtcbiAgYXBpS2V5OiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE9wZW5JbnRlcnByZXRlclNldHRpbmdzID0ge1xuICBhcGlLZXk6IFwiXCIsXG59O1xuXG5jbGFzcyBJbnN0YWxsYXRpb25HdWlkZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuICAgIHN1cGVyKGFwcCk7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgbGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5zZXRUZXh0KFwiT3BlbiBJbnRlcnByZXRlciBpcyBub3QgaW5zdGFsbGVkLlwiKTtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJwXCIsIHtcbiAgICAgIHRleHQ6IFwiVG8gaW5zdGFsbCwgcnVuIHRoZSBmb2xsb3dpbmcgY29tbWFuZCBpbiB5b3VyIHRlcm1pbmFsOlwiLFxuICAgIH0pO1xuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcInByZVwiLCB7IHRleHQ6IFwicGlwIGluc3RhbGwgb3Blbi1pbnRlcnByZXRlclwiIH0pO1xuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBcIkZvciBtb3JlIGluZm9ybWF0aW9uLCB2aXNpdDpcIiB9KTtcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJhXCIsIHtcbiAgICAgIHRleHQ6IFwiT3BlbiBJbnRlcnByZXRlciBEb2N1bWVudGF0aW9uXCIsXG4gICAgICBocmVmOiBcImh0dHBzOi8vZG9jcy5vcGVuaW50ZXJwcmV0ZXIuY29tL2dldHRpbmctc3RhcnRlZC9pbnRyb2R1Y3Rpb25cIixcbiAgICB9KTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgbGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICB9XG59XG5cbmNsYXNzIEludGVycHJldGVySW5wdXRNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgcmVzdWx0OiBzdHJpbmcgPSBcIlwiO1xuICBvblN1Ym1pdDogKHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvblN1Ym1pdDogKHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiRW50ZXIgY29tbWFuZCBmb3IgT3BlbiBJbnRlcnByZXRlclwiIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKFwiQ29tbWFuZFwiKS5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgdGV4dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuYWRkQnV0dG9uKChidG4pID0+XG4gICAgICBidG5cbiAgICAgICAgLnNldEJ1dHRvblRleHQoXCJTdWJtaXRcIilcbiAgICAgICAgLnNldEN0YSgpXG4gICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vblN1Ym1pdCh0aGlzLnJlc3VsdCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cblxuY2xhc3MgSW50ZXJwcmV0ZXJDaGF0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIHByaXZhdGUgaW50ZXJwcmV0ZXI6IENoaWxkUHJvY2VzcztcbiAgcHJpdmF0ZSBpbnB1dEVsITogSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgcHJpdmF0ZSBvdXRwdXRFbCE6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIGJ1dHRvbkNvbnRhaW5lciE6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIHllc0J1dHRvbiE6IEhUTUxCdXR0b25FbGVtZW50O1xuICBwcml2YXRlIG5vQnV0dG9uITogSFRNTEJ1dHRvbkVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGludGVycHJldGVyOiBDaGlsZFByb2Nlc3MpIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMuaW50ZXJwcmV0ZXIgPSBpbnRlcnByZXRlcjtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJPcGVuIEludGVycHJldGVyIENoYXRcIiB9KTtcblxuICAgIHRoaXMub3V0cHV0RWwgPSBjb250ZW50RWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwiaW50ZXJwcmV0ZXItb3V0cHV0XCIgfSk7XG4gICAgdGhpcy5vdXRwdXRFbC5zdHlsZS5oZWlnaHQgPSBcIjQwMHB4XCI7XG4gICAgdGhpcy5vdXRwdXRFbC5zdHlsZS5vdmVyZmxvd1kgPSBcInNjcm9sbFwiO1xuICAgIHRoaXMub3V0cHV0RWwuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgI2NjY1wiO1xuICAgIHRoaXMub3V0cHV0RWwuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgIHRoaXMub3V0cHV0RWwuc3R5bGUubWFyZ2luQm90dG9tID0gXCIxMHB4XCI7XG5cbiAgICB0aGlzLmNyZWF0ZUlucHV0QXJlYSgpO1xuICAgIHRoaXMuY3JlYXRlWWVzTm9CdXR0b25zKCk7XG5cbiAgICBjb25zdCBzZW5kQnV0dG9uID0gY29udGVudEVsLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHsgdGV4dDogXCJTZW5kXCIgfSk7XG4gICAgc2VuZEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4gdGhpcy5zZW5kTWVzc2FnZSgpO1xuXG4gICAgdGhpcy5zZXR1cEludGVycHJldGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwSW50ZXJwcmV0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJwcmV0ZXIuc3Rkb3V0KSB7XG4gICAgICB0aGlzLmludGVycHJldGVyLnN0ZG91dC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5hcHBlbmRPdXRwdXQoZGF0YS50b1N0cmluZygpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmludGVycHJldGVyLnN0ZGVycikge1xuICAgICAgdGhpcy5pbnRlcnByZXRlci5zdGRlcnIub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwZW5kT3V0cHV0KGBFcnJvcjogJHtkYXRhLnRvU3RyaW5nKCl9YCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVycHJldGVyLm9uKFwiY2xvc2VcIiwgKGNvZGUpID0+IHtcbiAgICAgIHRoaXMuYXBwZW5kT3V0cHV0KGBJbnRlcnByZXRlciBjbG9zZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy5pbnRlcnByZXRlci5raWxsKCk7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgY29udGVudEVsLmVtcHR5KCk7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZE91dHB1dCh0ZXh0OiBzdHJpbmcsIGlzRXJyb3I6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIC8vIFNwbGl0IHRoZSB0ZXh0IGludG8gc21hbGxlciBjaHVua3MgaWYgaXQncyB2ZXJ5IGxvbmdcbiAgICBjb25zdCBjaHVua3MgPSB0ZXh0Lm1hdGNoKC8uezEsMTAwMH0vZykgfHwgW107XG5cbiAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLm91dHB1dEVsLmNyZWF0ZUVsKFwicFwiKTtcbiAgICAgIHAudGV4dENvbnRlbnQgPSBjaHVuaztcbiAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgIHAuc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2Nyb2xsIHRvIHRoZSBib3R0b21cbiAgICB0aGlzLm91dHB1dEVsLnNjcm9sbFRvcCA9IHRoaXMub3V0cHV0RWwuc2Nyb2xsSGVpZ2h0O1xuXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBjb2RlIGV4ZWN1dGlvbiBwcm9tcHRcbiAgICBpZiAodGV4dC50cmltKCkuZW5kc1dpdGgoXCJXb3VsZCB5b3UgbGlrZSB0byBydW4gdGhpcyBjb2RlPyAoeS9uKVwiKSkge1xuICAgICAgdGhpcy5zaG93WWVzTm9CdXR0b25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvd0lucHV0QXJlYSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2VuZE1lc3NhZ2Uob3ZlcnJpZGVNZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgbGV0IG1lc3NhZ2U6IHN0cmluZztcbiAgICBpZiAob3ZlcnJpZGVNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gb3ZlcnJpZGVNZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gdGhpcy5pbnB1dEVsLnZhbHVlO1xuICAgICAgdGhpcy5pbnB1dEVsLnZhbHVlID0gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnRlcnByZXRlci5zdGRpbikge1xuICAgICAgdGhpcy5pbnRlcnByZXRlci5zdGRpbi53cml0ZShtZXNzYWdlICsgXCJcXG5cIik7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kT3V0cHV0KGBZb3U6ICR7bWVzc2FnZX1gKTtcbiAgICB0aGlzLnNob3dJbnB1dEFyZWEoKTsgLy8gUmVzZXQgdG8gaW5wdXQgYXJlYSBhZnRlciBzZW5kaW5nXG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUlucHV0QXJlYSgpIHtcbiAgICB0aGlzLmlucHV0RWwgPSB0aGlzLmNvbnRlbnRFbC5jcmVhdGVFbChcInRleHRhcmVhXCIsIHtcbiAgICAgIGNsczogXCJpbnRlcnByZXRlci1pbnB1dFwiLFxuICAgIH0pO1xuICAgIHRoaXMuaW5wdXRFbC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHRoaXMuaW5wdXRFbC5zdHlsZS5oZWlnaHQgPSBcIjEwMHB4XCI7XG4gICAgdGhpcy5pbnB1dEVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVllc05vQnV0dG9ucygpIHtcbiAgICB0aGlzLmJ1dHRvbkNvbnRhaW5lciA9IHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgIGNsczogXCJ5ZXMtbm8tYnV0dG9uc1wiLFxuICAgIH0pO1xuICAgIHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICB0aGlzLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwic3BhY2UtYmV0d2VlblwiO1xuICAgIHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLm1hcmdpblRvcCA9IFwiMTBweFwiO1xuXG4gICAgdGhpcy55ZXNCdXR0b24gPSB0aGlzLmJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiWWVzXCIgfSk7XG4gICAgdGhpcy55ZXNCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZTZmZmU2XCI7IC8vIGZhaW50IGdyZWVuXG4gICAgdGhpcy55ZXNCdXR0b24uc3R5bGUuY29sb3IgPSBcIiMwMDY2MDBcIjtcbiAgICB0aGlzLnllc0J1dHRvbi5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjMDA2NjAwXCI7XG4gICAgdGhpcy55ZXNCdXR0b24uc3R5bGUucGFkZGluZyA9IFwiMTBweCAyMHB4XCI7XG4gICAgdGhpcy55ZXNCdXR0b24uc3R5bGUuYm9yZGVyUmFkaXVzID0gXCI1cHhcIjtcbiAgICB0aGlzLnllc0J1dHRvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblxuICAgIHRoaXMubm9CdXR0b24gPSB0aGlzLmJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiTm9cIiB9KTtcbiAgICB0aGlzLm5vQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiI2ZmZTZlNlwiOyAvLyBmYWludCByZWRcbiAgICB0aGlzLm5vQnV0dG9uLnN0eWxlLmNvbG9yID0gXCIjNjYwMDAwXCI7XG4gICAgdGhpcy5ub0J1dHRvbi5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjNjYwMDAwXCI7XG4gICAgdGhpcy5ub0J1dHRvbi5zdHlsZS5wYWRkaW5nID0gXCIxMHB4IDIwcHhcIjtcbiAgICB0aGlzLm5vQnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9IFwiNXB4XCI7XG4gICAgdGhpcy5ub0J1dHRvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblxuICAgIHRoaXMueWVzQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlKFwieVwiKTtcbiAgICB0aGlzLm5vQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlKFwiblwiKTtcblxuICAgIHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfVxuXG4gIHByaXZhdGUgc2hvd0lucHV0QXJlYSgpIHtcbiAgICB0aGlzLmlucHV0RWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB0aGlzLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cblxuICBwcml2YXRlIHNob3dZZXNOb0J1dHRvbnMoKSB7XG4gICAgdGhpcy5pbnB1dEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB0aGlzLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wZW5JbnRlcnByZXRlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gIHNldHRpbmdzITogT3BlbkludGVycHJldGVyU2V0dGluZ3M7XG4gIHByaXZhdGUgaW50ZXJwcmV0ZXJJbnN0YWxsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgT3BlbkludGVycHJldGVyU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInJ1bi1pbnRlcnByZXRlclwiLFxuICAgICAgbmFtZTogXCJSdW4gT3BlbiBJbnRlcnByZXRlclwiLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucnVuSW50ZXJwcmV0ZXIoKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgfVxuXG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0ludGVycHJldGVySW5zdGFsbGF0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY29tbWFuZCA9ICckU0hFTEwgLWkgLWMgXCJ3aGljaCBpbnRlcnByZXRlclwiJztcbiAgICAgIGNvbnNvbGUubG9nKFwiRXhlY3V0aW5nIGNvbW1hbmQ6XCIsIGNvbW1hbmQpO1xuXG4gICAgICBleGVjKGNvbW1hbmQsIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZpbmRpbmcgaW50ZXJwcmV0ZXI6XCIsIGVycm9yKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0ZGVycjpcIiwgc3RkZXJyKTtcbiAgICAgICAgICB0aGlzLmludGVycHJldGVySW5zdGFsbGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXJQYXRoID0gc3Rkb3V0LnRyaW0oKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkludGVycHJldGVyIGZvdW5kIGF0OlwiLCBpbnRlcnByZXRlclBhdGgpO1xuICAgICAgICAgIHRoaXMuaW50ZXJwcmV0ZXJJbnN0YWxsZWQgPSAhIWludGVycHJldGVyUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIkludGVycHJldGVyIGluc3RhbGxlZDpcIiwgdGhpcy5pbnRlcnByZXRlckluc3RhbGxlZCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRJbnRlcnByZXRlclByb2ZpbGVQYXRoKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgaG9tZWRpciA9IG9zLmhvbWVkaXIoKTtcbiAgICBjb25zdCBwcm9maWxlRGlyID0gcGF0aC5qb2luKFxuICAgICAgaG9tZWRpcixcbiAgICAgIFwiTGlicmFyeVwiLFxuICAgICAgXCJBcHBsaWNhdGlvbiBTdXBwb3J0XCIsXG4gICAgICBcIm9wZW4taW50ZXJwcmV0ZXJcIixcbiAgICAgIFwicHJvZmlsZXNcIlxuICAgICk7XG4gICAgY29uc3QgcHJvZmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvZmlsZURpciwgXCJvYnNpZGlhbi5weVwiKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0c1xuICAgIGF3YWl0IGZzLm1rZGlyKHByb2ZpbGVEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGVtcHR5IHByb2ZpbGUgZmlsZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCEoYXdhaXQgZnMuc3RhdChwcm9maWxlUGF0aCkuY2F0Y2goKCkgPT4gZmFsc2UpKSkge1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgICBwcm9maWxlUGF0aCxcbiAgICAgICAgXCIjIE9ic2lkaWFuIHByb2ZpbGUgZm9yIE9wZW4gSW50ZXJwcmV0ZXJcXG5cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZmlsZVBhdGg7XG4gIH1cblxuICBwcml2YXRlIGdldFZhdWx0UGF0aCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcbiAgICBpZiAoYWRhcHRlciAmJiBcImJhc2VQYXRoXCIgaW4gYWRhcHRlcikge1xuICAgICAgcmV0dXJuIChhZGFwdGVyIGFzIGFueSkuYmFzZVBhdGg7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBwcmV2aW91cyBtZXRob2QgaWYgYmFzZVBhdGggaXMgbm90IGF2YWlsYWJsZVxuICAgIGNvbnN0IHJvb3RGb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRSb290KCk7XG4gICAgaWYgKHJvb3RGb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICByZXR1cm4gcm9vdEZvbGRlci5wYXRoO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSB2YXVsdCBwYXRoXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgcnVuSW50ZXJwcmV0ZXIoKSB7XG4gICAgYXdhaXQgdGhpcy5jaGVja0ludGVycHJldGVySW5zdGFsbGF0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmludGVycHJldGVySW5zdGFsbGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkludGVycHJldGVyIG5vdCBpbnN0YWxsZWQsIHNob3dpbmcgbW9kYWxcIik7XG4gICAgICBuZXcgSW5zdGFsbGF0aW9uR3VpZGVNb2RhbCh0aGlzLmFwcCkub3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5ldyBJbnRlcnByZXRlcklucHV0TW9kYWwodGhpcy5hcHAsIChjb21tYW5kKSA9PiB7XG4gICAgICB0aGlzLmV4ZWN1dGVJbnRlcnByZXRlckNvbW1hbmQoY29tbWFuZCk7XG4gICAgfSkub3BlbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBleGVjdXRlSW50ZXJwcmV0ZXJDb21tYW5kKGNvbW1hbmQ6IHN0cmluZykge1xuICAgIGNvbnN0IHByb2ZpbGVQYXRoID0gYXdhaXQgdGhpcy5nZXRJbnRlcnByZXRlclByb2ZpbGVQYXRoKCk7XG4gICAgY29uc3QgdmF1bHRQYXRoID0gdGhpcy5nZXRWYXVsdFBhdGgoKTtcblxuICAgIGlmICghdmF1bHRQYXRoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVmF1bHQgcGF0aCBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZC5cIik7XG4gICAgICBuZXcgTm90aWNlKFxuICAgICAgICBcIlVuYWJsZSB0byBkZXRlcm1pbmUgdmF1bHQgcGF0aC4gUGxlYXNlIGNoZWNrIGNvbnNvbGUgZm9yIGRldGFpbHMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJwcmV0ZXJQYXRoID0gYXdhaXQgdGhpcy5nZXRJbnRlcnByZXRlclBhdGgoKTtcbiAgICBpZiAoIWludGVycHJldGVyUGF0aCkge1xuICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgXCJVbmFibGUgdG8gZmluZCB0aGUgaW50ZXJwcmV0ZXIgZXhlY3V0YWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSBpdCdzIGluc3RhbGxlZCBhbmQgaW4geW91ciBQQVRILlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVudiA9IHsgLi4ucHJvY2Vzcy5lbnYsIE9QRU5BSV9BUElfS0VZOiB0aGlzLnNldHRpbmdzLmFwaUtleSB9O1xuXG4gICAgLy8gRXNjYXBlIHRoZSBwcm9maWxlIHBhdGggZm9yIHNoZWxsIHVzYWdlXG4gICAgY29uc3QgZXNjYXBlZFByb2ZpbGVQYXRoID0gcHJvZmlsZVBhdGgucmVwbGFjZSgvJy9nLCBcIidcXFxcJydcIik7XG5cbiAgICBjb25zdCBjaGlsZCA9IHNwYXduKFxuICAgICAgaW50ZXJwcmV0ZXJQYXRoLFxuICAgICAgW1wiLS1wcm9maWxlXCIsIGAnJHtlc2NhcGVkUHJvZmlsZVBhdGh9J2BdLFxuICAgICAge1xuICAgICAgICBjd2Q6IHZhdWx0UGF0aCxcbiAgICAgICAgZW52OiBlbnYsXG4gICAgICAgIHNoZWxsOiB0cnVlLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoY2hpbGQuc3RkaW4pIHtcbiAgICAgIGNoaWxkLnN0ZGluLndyaXRlKGNvbW1hbmQgKyBcIlxcblwiKTtcbiAgICB9XG5cbiAgICBuZXcgSW50ZXJwcmV0ZXJDaGF0TW9kYWwodGhpcy5hcHAsIGNoaWxkKS5vcGVuKCk7XG4gIH1cblxuICBwcml2YXRlIGdldEludGVycHJldGVyUGF0aCgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBpc1dpbmRvd3NcbiAgICAgICAgPyBcIndoZXJlIGludGVycHJldGVyXCJcbiAgICAgICAgOiBcIiRTSEVMTCAtaSAtYyAnd2hpY2ggaW50ZXJwcmV0ZXInXCI7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiRXhlY3V0aW5nIGNvbW1hbmQ6XCIsIGNvbW1hbmQpO1xuXG4gICAgICBleGVjKGNvbW1hbmQsIGFzeW5jIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZpbmRpbmcgaW50ZXJwcmV0ZXI6XCIsIGVycm9yKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0ZG91dDpcIiwgc3Rkb3V0KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0ZGVycjpcIiwgc3RkZXJyKTtcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb21tb24gcGF0aHNcbiAgICAgICAgICBjb25zdCBjb21tb25QYXRocyA9IFtcbiAgICAgICAgICAgIFwiL3Vzci9sb2NhbC9iaW4vaW50ZXJwcmV0ZXJcIixcbiAgICAgICAgICAgIFwiL3Vzci9iaW4vaW50ZXJwcmV0ZXJcIixcbiAgICAgICAgICAgIGAke29zLmhvbWVkaXIoKX0vTGlicmFyeS9QeXRob24vMy4xMS9iaW4vaW50ZXJwcmV0ZXJgLFxuICAgICAgICAgICAgYCR7b3MuaG9tZWRpcigpfS9MaWJyYXJ5L1B5dGhvbi8zLjEwL2Jpbi9pbnRlcnByZXRlcmAsXG4gICAgICAgICAgICBgJHtvcy5ob21lZGlyKCl9L0xpYnJhcnkvUHl0aG9uLzMuOS9iaW4vaW50ZXJwcmV0ZXJgLFxuICAgICAgICAgIF07XG4gICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbW1vblBhdGhzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBmcy5hY2Nlc3MocGF0aCk7XG4gICAgICAgICAgICAgIHJlc29sdmUocGF0aCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAvLyBQYXRoIGRvZXNuJ3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGUsIGNvbnRpbnVlIHRvIG5leHQgcGF0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW50ZXJwcmV0ZXIgZm91bmQgYXQ6XCIsIHN0ZG91dC50cmltKCkpO1xuICAgICAgICAgIHJlc29sdmUoc3Rkb3V0LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb251bmxvYWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJ1bmxvYWRpbmcgb3BlbiBpbnRlcnByZXRlciBwbHVnaW5cIik7XG4gIH1cbn1cblxuY2xhc3MgT3BlbkludGVycHJldGVyU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICBwbHVnaW46IE9wZW5JbnRlcnByZXRlclBsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBPcGVuSW50ZXJwcmV0ZXJQbHVnaW4pIHtcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICBkaXNwbGF5KCk6IHZvaWQge1xuICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiT3BlbiBJbnRlcnByZXRlciBTZXR0aW5nc1wiIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIk9wZW5BSSBBUEkgS2V5XCIpXG4gICAgICAuc2V0RGVzYyhcIkVudGVyIHlvdXIgT3BlbkFJIEFQSSBrZXlcIilcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgeW91ciBhcGkga2V5XCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaUtleSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcGlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFRTztBQUNQLDJCQUEwQztBQUMxQyxXQUFzQjtBQUN0QixTQUFvQjtBQUNwQixTQUFvQjtBQU1wQixJQUFNLG1CQUE0QztBQUFBLEVBQ2hELFFBQVE7QUFDVjtBQUVBLElBQU0seUJBQU4sY0FBcUMsc0JBQU07QUFBQSxFQUN6QyxZQUFZLEtBQVU7QUFDcEIsVUFBTSxHQUFHO0FBQUEsRUFDWDtBQUFBLEVBRUEsU0FBUztBQUNQLFFBQUksRUFBRSxVQUFVLElBQUk7QUFDcEIsY0FBVSxRQUFRLG9DQUFvQztBQUN0RCxjQUFVLFNBQVMsS0FBSztBQUFBLE1BQ3RCLE1BQU07QUFBQSxJQUNS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
